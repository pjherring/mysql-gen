package def

import (
	"encoding/json"
	"sort"
	"strings"

	"github.com/pjherring/mysql-gen/util"
)

type rawDef struct {
	Name          string            `json:"name"`
	Fields        map[string]string `json:"fields"`
	Queries       map[string]string `json:"queries"`
	PrimaryKeys   []string          `json:"primary_keys"`
	AutoGenerated []string          `json:"auto_generated"`
}

func ParseTable(b []byte) (Table, error) {

	retval := Table{
		Fields:      Fields{},
		fieldMap:    map[string]*Field{},
		Queries:     map[string]Query{},
		PrimaryKeys: Fields{},
	}

	var raw rawDef

	if err := json.Unmarshal(b, &raw); err != nil {
		return retval, err
	}

	retval.Raw = raw.Name
	retval.Name = strings.Title(raw.Name)
	if retval.Name[len(retval.Name)-1] == 's' {
		retval.Name = retval.Name[0 : len(retval.Name)-1]
	}

	for name, t := range raw.Fields {
		f := &Field{
			Arg:  util.UnderscoreToCamelCase(name),
			Type: t,
			Raw:  name,
		}

		f.Name = strings.Title(f.Arg)

		retval.Fields = append(retval.Fields, f)
		retval.fieldMap[name] = f
	}

	sort.Sort(retval.Fields)

	for name, sql := range raw.Queries {
		q := Query{
			Name:         strings.Title(name),
			IsMulti:      isMulti(name),
			Params:       parseQueryFields(sql, retval.fieldMap),
			SelectFields: parseSelectFields(sql, retval.fieldMap),
			Sql:          sql,
		}

		retval.Queries[name] = q
	}

	for _, column := range raw.PrimaryKeys {
		retval.fieldMap[column].IsPrimaryKey = true
		retval.PrimaryKeys = append(retval.PrimaryKeys, retval.fieldMap[column])
	}

	for _, column := range raw.AutoGenerated {
		retval.fieldMap[column].IsAutoGenerated = true
	}

	return retval, nil
}

func isMulti(sql string) bool {
	return strings.Contains(sql, "Many")
}

func parseQueryFields(sql string, fields map[string]*Field) []*Field {

	retval := []*Field{}

	parts := strings.Split(sql, " ")
	for i, part := range parts {
		if part != "?" {
			continue
		}

		for j := i - 1; j > 0; j-- {
			if f, ok := fields[parts[j]]; ok {
				retval = append(retval, f)
				break
			} else if strings.ToUpper(parts[j]) == "LIMIT" {
				retval = append(retval, &Field{
					Arg:  "limit",
					Name: "Limit",
					Raw:  "LIMIT",
				})
				break
			} else if strings.ToUpper(parts[j]) == "OFFSET" {
				retval = append(retval, &Field{
					Arg:  "offset",
					Name: "Offset",
					Raw:  "OFFSET",
				})
				break
			}
		}
	}

	return retval
}

const SELECT = "SELECT "
const FROM = "FROM"

func parseSelectFields(sql string, fields map[string]*Field) []*Field {

	selectFields := sql[len(SELECT):strings.Index(sql, FROM)]
	if strings.Contains(selectFields, "*") {
		return []*Field{}
	}

	var retval []*Field

	selectFieldParts := strings.Split(selectFields, ",")

	for _, part := range selectFieldParts {
		part = strings.TrimSpace(part)
		if f, ok := fields[part]; ok {
			retval = append(retval, f)
		}
	}

	return retval
}
